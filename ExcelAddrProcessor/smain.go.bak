package main

import (
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"

	"github.com/xuri/excelize/v2"
)

func main() {
	fmt.Println("感谢黄总选择并使用我们的软件，当前版本为0.2。我们期待与您一起见证软件的成长与进步。如果您在使用过程中有任何建议或反馈，欢迎随时与我们联系。")
	fmt.Print("请输入文件名（包含文件后缀，如：data.xlsx）: ")
	var response string
	fmt.Scanln(&response)
	// response = "data.xlsx"

	// 打开 Excel 文件
	f, err := excelize.OpenFile(response)
	if err != nil {
		log.Fatalf("无法打开文件: %v", err)
	}
	defer f.Close()

	// 获取第一个工作表
	sheetList := f.GetSheetList()
	if len(sheetList) == 0 {
		log.Fatalf("文件中没有工作表")
	}
	sheetName := sheetList[0]

	// 获取所有行
	rows, err := f.GetRows(sheetName)
	if err != nil {
		log.Fatalf("无法获取行: %v", err)
	}

	// 插入新列
	if err := insertColumns(f, sheetName); err != nil {
		log.Fatalf("无法插入新列: %v", err)
	}

	// 缓存正则表达式
	offlineCommissionRe := regexp.MustCompile(`提(\d+)`)

	for i, row := range rows {
		if i == 0 {
			setHeader(f, sheetName)
			continue
		}

		if len(row) > 3 {
			processRow(f, sheetName, i+1, row, offlineCommissionRe)
		}
	}

	// 删除不必要的列
	removeColumns(f, sheetName, []string{"O", "S", "S"})

	// 保存修改后的文件
	if err := f.SaveAs("output.xlsx"); err != nil {
		log.Fatalf("无法保存文件: %v", err)
	}

	fmt.Println("处理完成，结果已保存到 output.xlsx")
}

func insertColumns(f *excelize.File, sheetName string) error {
	if err := f.InsertCols(sheetName, "E", 4); err != nil {
		return err
	}
	if err := f.InsertCols(sheetName, "L", 3); err != nil {
		return err
	}
	return nil
}

func setHeader(f *excelize.File, sheetName string) {
	headers := []struct {
		col, title string
	}{
		{"E1", "省"},
		{"F1", "市"},
		{"G1", "县/区"},
		{"H1", "详细地址"},
		{"L1", "合计"},
		{"M1", "美团券"},
		{"N1", "线下交提成"},
	}

	for _, header := range headers {
		f.SetCellValue(sheetName, header.col, header.title)
	}
}

func processRow(f *excelize.File, sheetName string, rowIndex int, row []string, offlineCommissionRe *regexp.Regexp) {
	// 处理地址
	province, city, district, detail := parseAddress(row[3])
	setCellValues(f, sheetName, rowIndex, map[string]interface{}{
		"E": province,
		"F": city,
		"G": district,
		"H": detail,
	})

	// 处理预约时间
	if len(row) > 14 {
		f.SetCellValue(sheetName, fmt.Sprintf("V%d", rowIndex), extractDate(row[14]))
	}

	// 处理跟单备注
	if len(row) > 15 {
		f.SetCellValue(sheetName, fmt.Sprintf("W%d", rowIndex), strings.TrimSpace(strings.Replace(row[15], "后台导入", "", -1)))
	}

	// 处理回访内容
	if len(row) > 16 {
		processFeedback(f, sheetName, rowIndex, row[16], offlineCommissionRe)
	}

	// 处理支付状态
	if len(row) > 10 {
		processPaymentStatus(f, sheetName, rowIndex, row[10])
	}

	// 计算合计
	calculateTotal(f, sheetName, rowIndex)

	// 修改订单状态和派单师傅
	if len(row) > 11 {
		processOrderStatus(f, sheetName, rowIndex, row[11], city)
	}
}

func processFeedback(f *excelize.File, sheetName string, rowIndex int, feedback string, offlineCommissionRe *regexp.Regexp) {
	if strings.Contains(feedback, "验券") && (strings.Contains(feedback, "25") || strings.Contains(feedback, "30")) {
		f.SetCellValue(sheetName, fmt.Sprintf("M%d", rowIndex), 50)
	}

	// 处理线下交提成
	offlineCommission := extractOfflineCommission(feedback, offlineCommissionRe)
	if offlineCommission > 0 {
		f.SetCellValue(sheetName, fmt.Sprintf("N%d", rowIndex), offlineCommission)
	}
}

func processPaymentStatus(f *excelize.File, sheetName string, rowIndex int, paymentStatus string) {
	if paymentStatus == "无需支付" {
		clearCells(f, sheetName, rowIndex, []string{"P", "Q", "R"})
	} else if paymentStatus == "未支付" {
		style, _ := f.NewStyle(&excelize.Style{
			Font: &excelize.Font{Color: "FF0000"},
		})
		f.SetCellStyle(sheetName, fmt.Sprintf("P%d", rowIndex), fmt.Sprintf("R%d", rowIndex), style)
	}
}

func calculateTotal(f *excelize.File, sheetName string, rowIndex int) {
	repairFee, _ := f.GetCellValue(sheetName, fmt.Sprintf("P%d", rowIndex))
	materialFee, _ := f.GetCellValue(sheetName, fmt.Sprintf("Q%d", rowIndex))
	meituanCoupon, _ := f.GetCellValue(sheetName, fmt.Sprintf("M%d", rowIndex))

	total := sumFees(repairFee, materialFee, meituanCoupon)
	f.SetCellValue(sheetName, fmt.Sprintf("L%d", rowIndex), total)

	switch {
	case total >= 70:
		f.SetCellValue(sheetName, fmt.Sprintf("K%d", rowIndex), "成功订单")
	case total > 0 && total < 70:
		f.SetCellValue(sheetName, fmt.Sprintf("K%d", rowIndex), "只收上门费")
	default:
		f.SetCellValue(sheetName, fmt.Sprintf("K%d", rowIndex), "待服务")
	}
}

func processOrderStatus(f *excelize.File, sheetName string, rowIndex int, masterDispatcher, city string) {
	switch masterDispatcher {
	case "测试1":
		f.SetCellValue(sheetName, fmt.Sprintf("S%d", rowIndex), city+"-未派出")
	case "邓姐":
		f.SetCellValue(sheetName, fmt.Sprintf("S%d", rowIndex), city+"-邓姐外派")
	}
}

func removeColumns(f *excelize.File, sheetName string, cols []string) {
	for _, col := range cols {
		if err := f.RemoveCol(sheetName, col); err != nil {
			log.Printf("无法删除%s列: %v", col, err)
		}
	}
}

func setCellValues(f *excelize.File, sheetName string, rowIndex int, values map[string]interface{}) {
	for col, value := range values {
		f.SetCellValue(sheetName, fmt.Sprintf("%s%d", col, rowIndex), value)
	}
}

func clearCells(f *excelize.File, sheetName string, rowIndex int, cols []string) {
	for _, col := range cols {
		f.SetCellValue(sheetName, fmt.Sprintf("%s%d", col, rowIndex), "")
	}
}

func parseAddress(address string) (province, city, district, detail string) {
	parts := strings.SplitN(address, "市", 2)
	if len(parts) == 2 {
		// 处理 "省" 或 "自治区"
		cityParts := strings.SplitN(parts[0], "省", 2)
		if len(cityParts) != 2 {
			cityParts = strings.SplitN(parts[0], "自治区", 2)
			if len(cityParts) == 2 {
				province = cityParts[0] + "自治区"
				city = cityParts[1] + "市"
			} else {
				city = parts[0] + "市"
			}
		} else {
			province = cityParts[0] + "省"
			city = cityParts[1] + "市"
		}

		// 处理 "区" 或 "县"
		districtParts := strings.SplitN(parts[1], "区", 2)
		if len(districtParts) == 2 {
			district = districtParts[0] + "区"
			detail = districtParts[1]
		} else {
			districtParts = strings.SplitN(parts[1], "县", 2)
			if len(districtParts) == 2 {
				district = districtParts[0] + "县"
				detail = districtParts[1]
			} else {
				detail = parts[1]
			}
		}
	} else {
		detail = address
	}
	return
}

func extractDate(dateTime string) string {
	parts := strings.Split(dateTime, " ")
	if len(parts) > 0 {
		return parts[0]
	}
	return dateTime
}

func extractOfflineCommission(feedback string, re *regexp.Regexp) float64 {
	match := re.FindStringSubmatch(feedback)
	if len(match) > 1 {
		commission, err := strconv.ParseFloat(match[1], 64)
		if err == nil {
			return commission
		}
	}
	return 0
}

func sumFees(fees ...string) float64 {
	var total float64
	for _, fee := range fees {
		if value, err := strconv.ParseFloat(fee, 64); err == nil {
			total += value
		}
	}
	return total
}
